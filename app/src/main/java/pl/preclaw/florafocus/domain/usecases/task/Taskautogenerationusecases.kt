package pl.preclaw.florafocus.domain.usecase.task

import kotlinx.coroutines.flow.first
import pl.preclaw.florafocus.domain.model.*
import pl.preclaw.florafocus.domain.repository.PlantCatalogRepository
import pl.preclaw.florafocus.domain.repository.TaskRepository
import pl.preclaw.florafocus.domain.repository.UserPlantRepository
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject

/**
 * Auto-generate tasks from plant growth phase
 *
 * CRITICAL USE CASE FOR MVP
 *
 * Business Logic:
 * 1. Get plant's current phase and auto-tasks
 * 2. Calculate due dates based on phase entry date
 * 3. Create tasks with appropriate priorities
 * 4. Return created task IDs
 */
class AutoGenerateTasksFromPhaseUseCase @Inject constructor(
    private val taskRepository: TaskRepository,
    private val userPlantRepository: UserPlantRepository,
    private val plantCatalogRepository: PlantCatalogRepository
) {
    suspend operator fun invoke(
        userPlantId: String,
        newPhase: GrowthPhaseName
    ): Result<List<String>> {
        return try {
            // 1. Get user plant
            val userPlant = userPlantRepository.getUserPlantById(userPlantId)
                ?: return Result.failure(Exception("User plant not found"))

            // 2. Get catalog plant for phase definitions
            val catalogPlant = plantCatalogRepository.getPlantById(userPlant.catalogPlantId)
                ?: return Result.failure(Exception("Catalog plant not found"))

            // 3. Find the growth phase
            val phaseDefinition = catalogPlant.growthPhases.find { it.phaseName == newPhase }
                ?: return Result.failure(Exception("Phase not found in catalog"))

            // 4. Generate tasks from phase auto-tasks
            val createdTaskIds = mutableListOf<String>()
            // ✅ POPRAWIONE: Użyj currentPhase?.startDate zamiast currentPhaseStartDate
            val phaseEntryDate = userPlant.currentPhase?.startDate ?: System.currentTimeMillis()

            for (autoTask in phaseDefinition.autoTasks) {
                val task = createTaskFromTemplate(
                    userPlant = userPlant,
                    autoTask = autoTask,
                    phaseEntryDate = phaseEntryDate,
                    phaseName = newPhase
                )

                val taskId = taskRepository.createTask(task).getOrThrow()
                createdTaskIds.add(taskId)
            }

            Result.success(createdTaskIds)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun createTaskFromTemplate(
        userPlant: UserPlant,
        autoTask: AutoTask,
        phaseEntryDate: Long,
        phaseName: GrowthPhaseName
    ): Task {
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = phaseEntryDate
        calendar.add(Calendar.DAY_OF_YEAR, autoTask.triggerDayOffset)

        return Task(
            id = UUID.randomUUID().toString(),
            userId = userPlant.userId,
            title = autoTask.taskTitle,
            description = "${autoTask.taskDescription}\n\nFor: ${userPlant.customName} (${phaseName.name})",
            taskType = autoTask.taskType,
            priority = autoTask.priority,
            dueDate = calendar.timeInMillis,

            // ✅ WSZYSTKIE WYMAGANE PARAMETRY:
            dueTime = null,
            isAllDay = false,
            associatedPlantId = userPlant.id,  // ✅ DODANE
            associatedBedId = userPlant.location?.bedId,  // ✅ DODANE
            locationId = userPlant.location?.bedId,  // ✅ DODANE
            locationName = null,  // ✅ DODANE
            completed = false,
            completedDate = null,
            isRecurring = false,
            recurringTemplateId = null,
            isAutoGenerated = true,
            generatedFromPhaseId = phaseName.name,  // ✅ DODANE
            weatherDependent = isWeatherDependentTask(autoTask.taskType),  // ✅ DODANE
            idealWeatherConditions = emptyList(),  // ✅ DODANE
            linkedPlantId = userPlant.id,  // ✅ Użyj associatedPlantId
            linkedPhaseId = phaseName.name,
            imageUrls = emptyList(),
            notes = null,
            createdAt = System.currentTimeMillis(),
            updatedAt = System.currentTimeMillis()
        )
    }

    private fun isWeatherDependentTask(taskType: TaskType): Boolean {
        return when (taskType) {
            TaskType.WATERING -> true
            TaskType.FERTILIZING -> true
            TaskType.PRUNING -> false
            TaskType.PEST_CONTROL -> true
            TaskType.SOIL_CHECK -> false
            TaskType.TRANSPLANTING -> true
            TaskType.STAKING -> false
            TaskType.THINNING -> false
            TaskType.PINCHING -> false
            TaskType.OBSERVATION -> false
            TaskType.OTHER -> false
        }
    }
}

/**
 * Generate recurring tasks from template
 *
 * Business Logic:
 * 1. Get template configuration
 * 2. Calculate next X occurrences
 * 3. Create task instances
 */
class GenerateRecurringTasksUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(
        templateId: String,
        numberOfOccurrences: Int = 10
    ): Result<List<String>> {
        return try {
            val template = taskRepository.getRecurringTemplateById(templateId)
                ?: return Result.failure(Exception("Template not found"))

            val createdTaskIds = mutableListOf<String>()
            val calendar = Calendar.getInstance()

            // ✅ POPRAWIONE: Użyj startDate zamiast nextScheduledDate
            calendar.timeInMillis = template.startDate

            repeat(numberOfOccurrences) { occurrence ->
                val task = Task(
                    id = UUID.randomUUID().toString(),
                    userId = template.userId,
                    title = template.title,
                    description = template.description,
                    taskType = template.taskType,
                    priority = template.priority,
                    dueDate = calendar.timeInMillis,

                    // ✅ WSZYSTKIE WYMAGANE PARAMETRY:
                    dueTime = null,
                    isAllDay = false,
                    associatedPlantId = template.associatedPlantId,
                    associatedBedId = template.associatedBedId,
                    locationId = template.associatedBedId,
                    locationName = null,
                    completed = false,
                    completedDate = null,
                    isRecurring = true,
                    recurringTemplateId = template.id,
                    isAutoGenerated = true,
                    generatedFromPhaseId = null,
                    weatherDependent = false,
                    idealWeatherConditions = emptyList(),
                    linkedPlantId = template.associatedPlantId,
                    linkedPhaseId = null,
                    imageUrls = emptyList(),
                    notes = null,
                    createdAt = System.currentTimeMillis(),
                    updatedAt = System.currentTimeMillis()
                )

                val taskId = taskRepository.createTask(task).getOrThrow()
                createdTaskIds.add(taskId)

                // Calculate next occurrence based on pattern
                when (template.recurrencePattern.frequency) {
                    RecurrenceFrequency.DAILY -> calendar.add(Calendar.DAY_OF_YEAR, template.recurrencePattern.interval)
                    RecurrenceFrequency.WEEKLY -> calendar.add(Calendar.WEEK_OF_YEAR, template.recurrencePattern.interval)
                    RecurrenceFrequency.MONTHLY -> calendar.add(Calendar.MONTH, template.recurrencePattern.interval)
                    RecurrenceFrequency.YEARLY -> calendar.add(Calendar.YEAR, template.recurrencePattern.interval)
                    RecurrenceFrequency.CUSTOM -> calendar.add(Calendar.DAY_OF_YEAR, template.recurrencePattern.interval)
                }
            }

            Result.success(createdTaskIds)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Batch complete recurring tasks
 *
 * When user completes a recurring task, create next occurrence
 */
class CompleteRecurringTaskUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(taskId: String): Result<String?> {
        return try {
            val task = taskRepository.getTaskById(taskId)
                ?: return Result.failure(Exception("Task not found"))

            if (!task.isRecurring || task.recurringTemplateId == null) {
                // Just complete the task
                taskRepository.completeTask(taskId, System.currentTimeMillis())  // ✅ DODANE completedDate
                return Result.success(null)
            }

            // Get template
            val template = taskRepository.getRecurringTemplateById(task.recurringTemplateId)
                ?: return Result.failure(Exception("Template not found"))

            // Mark current as complete
            taskRepository.completeTask(taskId, System.currentTimeMillis())  // ✅ DODANE completedDate

            // Calculate next occurrence
            val calendar = Calendar.getInstance()
            calendar.timeInMillis = task.dueDate

            when (template.recurrencePattern.frequency) {
                RecurrenceFrequency.DAILY -> calendar.add(Calendar.DAY_OF_YEAR, template.recurrencePattern.interval)
                RecurrenceFrequency.WEEKLY -> calendar.add(Calendar.WEEK_OF_YEAR, template.recurrencePattern.interval)
                RecurrenceFrequency.MONTHLY -> calendar.add(Calendar.MONTH, template.recurrencePattern.interval)
                RecurrenceFrequency.YEARLY -> calendar.add(Calendar.YEAR, template.recurrencePattern.interval)
                RecurrenceFrequency.CUSTOM -> calendar.add(Calendar.DAY_OF_YEAR, template.recurrencePattern.interval)
            }

            // Create next occurrence
            val nextTask = task.copy(
                id = UUID.randomUUID().toString(),
                dueDate = calendar.timeInMillis,
                completed = false,
                completedDate = null,
                createdAt = System.currentTimeMillis(),
                updatedAt = System.currentTimeMillis()
            )

            val nextTaskId = taskRepository.createTask(nextTask).getOrThrow()
            Result.success(nextTaskId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Auto-generate tasks for newly planted user plants
 */
class AutoGenerateTasksForNewPlantUseCase @Inject constructor(
    private val autoGenerateTasksFromPhaseUseCase: AutoGenerateTasksFromPhaseUseCase
) {
    suspend operator fun invoke(
        userPlantId: String,
        initialPhase: GrowthPhaseName = GrowthPhaseName.GERMINATION
    ): Result<List<String>> {
        return autoGenerateTasksFromPhaseUseCase(userPlantId, initialPhase)
    }
}

// ==================== DATA CLASSES ====================

data class WeatherAlert(
    val message: String,
    val startDate: Long,
    val endDate: Long?
)