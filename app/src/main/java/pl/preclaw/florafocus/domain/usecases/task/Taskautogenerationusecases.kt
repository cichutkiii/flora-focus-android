package pl.preclaw.florafocus.domain.usecase.task

import kotlinx.coroutines.flow.first
import pl.preclaw.florafocus.domain.model.*
import pl.preclaw.florafocus.domain.repository.PlantCatalogRepository
import pl.preclaw.florafocus.domain.repository.TaskRepository
import pl.preclaw.florafocus.domain.repository.UserPlantRepository
import java.util.Calendar
import java.util.UUID
import javax.inject.Inject

/**
 * Auto-generate tasks from plant growth phase
 *
 * CRITICAL USE CASE FOR MVP
 *
 * Business Logic:
 * 1. Get plant's current phase and auto-tasks
 * 2. Calculate due dates based on phase entry date
 * 3. Create tasks with appropriate priorities
 * 4. Return created task IDs
 */
class AutoGenerateTasksFromPhaseUseCase @Inject constructor(
    private val taskRepository: TaskRepository,
    private val userPlantRepository: UserPlantRepository,
    private val plantCatalogRepository: PlantCatalogRepository
) {
    suspend operator fun invoke(
        userPlantId: String,
        newPhase: GrowthPhaseName
    ): Result<List<String>> {
        return try {
            // 1. Get user plant
            val userPlant = userPlantRepository.getUserPlantById(userPlantId)
                ?: return Result.failure(Exception("User plant not found"))

            // 2. Get catalog plant for phase definitions
            val catalogPlant = plantCatalogRepository.getPlantById(userPlant.catalogPlantId)
                ?: return Result.failure(Exception("Catalog plant not found"))

            // 3. Find the growth phase
            val phaseDefinition = catalogPlant.growthPhases.find { it.phaseName == newPhase }
                ?: return Result.failure(Exception("Phase not found in catalog"))

            // 4. Generate tasks from phase auto-tasks
            val createdTaskIds = mutableListOf<String>()
            val phaseEntryDate = userPlant.currentPhaseStartDate ?: System.currentTimeMillis()

            for (autoTask in phaseDefinition.autoTasks) {
                val task = createTaskFromTemplate(
                    userPlant = userPlant,
                    autoTask = autoTask,
                    phaseEntryDate = phaseEntryDate,
                    phaseName = newPhase
                )

                val taskId = taskRepository.createTask(task).getOrThrow()
                createdTaskIds.add(taskId)
            }

            Result.success(createdTaskIds)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun createTaskFromTemplate(
        userPlant: UserPlant,
        autoTask: AutoTask,
        phaseEntryDate: Long,
        phaseName: GrowthPhaseName
    ): Task {
        val calendar = Calendar.getInstance()
        calendar.timeInMillis = phaseEntryDate
        calendar.add(Calendar.DAY_OF_YEAR, autoTask.triggerDayOffset)

        return Task(
            id = UUID.randomUUID().toString(),
            userId = userPlant.userId,
            title = autoTask.taskTitle,
            description = "${autoTask.taskDescription}\n\nFor: ${userPlant.customName ?: "Plant"} (${phaseName.name})",
            taskType = autoTask.taskType,
            priority = autoTask.priority,
            dueDate = calendar.timeInMillis,
            completed = false,
            isAutoGenerated = true,
            linkedPlantId = userPlant.id,
            linkedPhaseId = phaseName.name,
            createdAt = System.currentTimeMillis(),
            updatedAt = System.currentTimeMillis()
        )
    }
}

/**
 * Generate recurring tasks from template
 *
 * Business Logic:
 * 1. Get template configuration
 * 2. Calculate next X occurrences
 * 3. Create task instances
 */
class GenerateRecurringTasksUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(
        templateId: String,
        numberOfOccurrences: Int = 10
    ): Result<List<String>> {
        return try {
            val template = taskRepository.getRecurringTemplateById(templateId)
                ?: return Result.failure(Exception("Template not found"))

            val createdTaskIds = mutableListOf<String>()
            val calendar = Calendar.getInstance()

            // Start from today or next scheduled date
            val startDate = template.nextScheduledDate ?: System.currentTimeMillis()
            calendar.timeInMillis = startDate

            repeat(numberOfOccurrences) { index ->
                val task = Task(
                    id = UUID.randomUUID().toString(),
                    userId = template.userId,
                    title = template.title,
                    description = template.description,
                    taskType = template.taskType,
                    priority = template.priority,
                    dueDate = calendar.timeInMillis,
                    completed = false,
                    isRecurring = true,
                    recurringTemplateId = templateId,
                    linkedPlantId = template.linkedPlantId,
                    createdAt = System.currentTimeMillis(),
                    updatedAt = System.currentTimeMillis()
                )

                val taskId = taskRepository.createTask(task).getOrThrow()
                createdTaskIds.add(taskId)

                // Calculate next occurrence
                when (template.recurrencePattern) {
                    RecurrencePattern.DAILY -> calendar.add(Calendar.DAY_OF_YEAR, template.intervalDays ?: 1)
                    RecurrencePattern.WEEKLY -> calendar.add(Calendar.WEEK_OF_YEAR, template.intervalDays ?: 1)
                    RecurrencePattern.MONTHLY -> calendar.add(Calendar.MONTH, template.intervalDays ?: 1)
                    RecurrencePattern.CUSTOM -> calendar.add(Calendar.DAY_OF_YEAR, template.intervalDays ?: 1)
                }
            }

            // Update template with next scheduled date
            val updatedTemplate = template.copy(
                nextScheduledDate = calendar.timeInMillis
            )
            taskRepository.updateRecurringTemplate(updatedTemplate)

            Result.success(createdTaskIds)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Reschedule tasks due to weather conditions
 *
 * Business Logic:
 * 1. Get tasks scheduled for affected dates
 * 2. Determine if task can be postponed (not urgent)
 * 3. Calculate new due date
 * 4. Update task
 */
class RescheduleTasksDueToWeatherUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(
        userId: String,
        weatherAlert: WeatherAlert
    ): Result<List<String>> {
        return try {
            // Get tasks in affected date range
            val affectedTasks = taskRepository.getTasksInDateRange(
                userId = userId,
                startDate = weatherAlert.startDate,
                endDate = weatherAlert.endDate ?: weatherAlert.startDate
            ).first()

            val rescheduledTaskIds = mutableListOf<String>()

            for (task in affectedTasks) {
                // Only reschedule if:
                // 1. Not urgent
                // 2. Weather-dependent type
                // 3. Not already completed
                if (task.priority != TaskPriority.URGENT &&
                    task.completed == false &&
                    isWeatherDependentTask(task.taskType)) {

                    // Calculate new date (after weather alert ends + 1 day)
                    val newDueDate = (weatherAlert.endDate ?: weatherAlert.startDate) + (24 * 60 * 60 * 1000)

                    val updatedTask = task.copy(
                        dueDate = newDueDate,
                        description = "${task.description}\n\n⚠️ Rescheduled due to: ${weatherAlert.message}",
                        updatedAt = System.currentTimeMillis()
                    )

                    taskRepository.updateTask(updatedTask)
                    rescheduledTaskIds.add(task.id)
                }
            }

            Result.success(rescheduledTaskIds)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    private fun isWeatherDependentTask(taskType: TaskType): Boolean {
        return when (taskType) {
            TaskType.WATERING -> true
            TaskType.FERTILIZING -> true
            TaskType.PRUNING -> false
            TaskType.PEST_CONTROL -> true
            TaskType.SOIL_CHECK -> false
            TaskType.TRANSPLANTING -> true
            TaskType.STAKING -> false
            TaskType.THINNING -> false
            TaskType.PINCHING -> false
            TaskType.OBSERVATION -> false
            TaskType.OTHER -> false
        }
    }
}

/**
 * Prioritize tasks by urgency and due date
 *
 * Business Logic:
 * Sorting algorithm:
 * 1. Overdue + Urgent = highest priority
 * 2. Overdue + High = second
 * 3. Due today + Urgent
 * 4. Due today + High
 * 5. Upcoming (next 7 days) by due date
 */
class PrioritizeTasksByUrgencyUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(userId: String): List<Task> {
        try {
            val allTasks = taskRepository.getTasks(userId).first()
            val now = System.currentTimeMillis()
            val todayEnd = getTodayEndTimestamp()
            val weekEnd = getWeekEndTimestamp()

            return allTasks
                .filter { !it.completed }
                .sortedWith(compareBy(
                    // Primary: Is overdue
                    { task -> if (task.dueDate < now) 0 else 1 },
                    // Secondary: Priority
                    { task ->
                        when (task.priority) {
                            TaskPriority.URGENT -> 0
                            TaskPriority.HIGH -> 1
                            TaskPriority.MEDIUM -> 2
                            TaskPriority.LOW -> 3
                        }
                    },
                    // Tertiary: Due date
                    { task -> task.dueDate }
                ))
        } catch (e: Exception) {
            return emptyList()
        }
    }

    private fun getTodayEndTimestamp(): Long {
        val calendar = Calendar.getInstance()
        calendar.set(Calendar.HOUR_OF_DAY, 23)
        calendar.set(Calendar.MINUTE, 59)
        calendar.set(Calendar.SECOND, 59)
        return calendar.timeInMillis
    }

    private fun getWeekEndTimestamp(): Long {
        val calendar = Calendar.getInstance()
        calendar.add(Calendar.DAY_OF_YEAR, 7)
        return calendar.timeInMillis
    }
}

/**
 * Batch complete recurring tasks
 *
 * When user completes a recurring task, create next occurrence
 */
class CompleteRecurringTaskUseCase @Inject constructor(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(taskId: String): Result<String?> {
        return try {
            val task = taskRepository.getTaskById(taskId)
                ?: return Result.failure(Exception("Task not found"))

            if (!task.isRecurring || task.recurringTemplateId == null) {
                // Just complete the task
                taskRepository.completeTask(taskId)
                return Result.success(null)
            }

            // Get template
            val template = taskRepository.getRecurringTemplateById(task.recurringTemplateId)
                ?: return Result.failure(Exception("Template not found"))

            // Mark current as complete
            taskRepository.completeTask(taskId)

            // Calculate next occurrence
            val calendar = Calendar.getInstance()
            calendar.timeInMillis = task.dueDate

            when (template.recurrencePattern) {
                RecurrencePattern.DAILY -> calendar.add(Calendar.DAY_OF_YEAR, template.intervalDays ?: 1)
                RecurrencePattern.WEEKLY -> calendar.add(Calendar.WEEK_OF_YEAR, template.intervalDays ?: 1)
                RecurrencePattern.MONTHLY -> calendar.add(Calendar.MONTH, template.intervalDays ?: 1)
                RecurrencePattern.CUSTOM -> calendar.add(Calendar.DAY_OF_YEAR, template.intervalDays ?: 1)
            }

            // Create next occurrence
            val nextTask = task.copy(
                id = UUID.randomUUID().toString(),
                dueDate = calendar.timeInMillis,
                completed = false,
                completedDate = null,
                createdAt = System.currentTimeMillis(),
                updatedAt = System.currentTimeMillis()
            )

            val nextTaskId = taskRepository.createTask(nextTask).getOrThrow()
            Result.success(nextTaskId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Auto-generate tasks for newly planted user plants
 */
class AutoGenerateTasksForNewPlantUseCase @Inject constructor(
    private val autoGenerateTasksFromPhaseUseCase: AutoGenerateTasksFromPhaseUseCase
) {
    suspend operator fun invoke(
        userPlantId: String,
        initialPhase: GrowthPhaseName = GrowthPhaseName.GERMINATION
    ): Result<List<String>> {
        return autoGenerateTasksFromPhaseUseCase(userPlantId, initialPhase)
    }
}

// ==================== DATA CLASSES ====================

data class WeatherAlert(
    val message: String,
    val startDate: Long,
    val endDate: Long?
)